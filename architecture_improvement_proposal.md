# å—ä»˜ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ»ã‚³ãƒ¼ãƒ‰æ”¹å–„ææ¡ˆæ›¸

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: Reception Management System  
**å¯¾è±¡**: Rails 8.0.3 ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³  
**åˆ†ææ—¥**: 2025å¹´11æœˆ10æ—¥

---

## ğŸ“‹ ç›®æ¬¡

1. [ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼](#ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼)
2. [ç¾çŠ¶åˆ†æ](#ç¾çŠ¶åˆ†æ)
3. [é‡å¤§ãªå•é¡Œ](#é‡å¤§ãªå•é¡Œ)
4. [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ”¹å–„ææ¡ˆ](#ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ”¹å–„ææ¡ˆ)
5. [ã‚³ãƒ¼ãƒ‰å“è³ªæ”¹å–„ææ¡ˆ](#ã‚³ãƒ¼ãƒ‰å“è³ªæ”¹å–„ææ¡ˆ)
6. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ”¹å–„](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ”¹å–„)
7. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–)
8. [ãƒ†ã‚¹ãƒˆæˆ¦ç•¥](#ãƒ†ã‚¹ãƒˆæˆ¦ç•¥)
9. [å®Ÿè£…å„ªå…ˆåº¦](#å®Ÿè£…å„ªå…ˆåº¦)

---

## ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

### ğŸ¯ å…¨ä½“è©•ä¾¡

**ç·åˆã‚¹ã‚³ã‚¢: 7.0/10**

| é …ç›® | è©•ä¾¡ | ã‚³ãƒ¡ãƒ³ãƒˆ |
|------|------|----------|
| ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ | â­â­â­â­â˜† | ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®åˆ†é›¢ã¯è‰¯å¥½ã ãŒã€è¨­å®šç®¡ç†ã«èª²é¡Œ |
| ã‚³ãƒ¼ãƒ‰å“è³ª | â­â­â­â­â˜† | æ¦‚ã­è‰¯å¥½ã ãŒã€ä¸€éƒ¨ã«é‡è¤‡ã‚„ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚ã‚Š |
| ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ | â­â­â­â˜†â˜† | åŸºæœ¬çš„ãªå¯¾ç­–ã¯ã‚ã‚‹ãŒã€æ”¹å–„ã®ä½™åœ°ã‚ã‚Š |
| ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ | â­â˜†â˜†â˜†â˜† | ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒæœªå®Ÿè£…ï¼ˆè‡´å‘½çš„ï¼‰ |
| ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ | â­â­â­â­â­ | éå¸¸ã«è©³ç´°ã§æ•´ç†ã•ã‚Œã¦ã„ã‚‹ |
| ä¿å®ˆæ€§ | â­â­â­â­â˜† | è‰¯å¥½ã ãŒã€è¨­å®šã®ä¸€å…ƒåŒ–ãŒå¿…è¦ |

### ğŸš¨ æœ€é‡è¦èª²é¡Œï¼ˆä»Šã™ãå¯¾å¿œã™ã¹ãï¼‰

1. **AppConfigæœªå®šç¾©å•é¡Œ** - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ·å‹•ã—ãªã„ï¼ˆè‡´å‘½çš„ï¼‰
2. **ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ä¸åœ¨** - å“è³ªä¿è¨¼ãŒã§ããªã„
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¸çµ±ä¸€** - äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§

---

## ç¾çŠ¶åˆ†æ

### âœ… å„ªã‚Œã¦ã„ã‚‹ç‚¹

#### 1. ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®é©åˆ‡ãªåˆ†é›¢
```ruby
# è‰¯ã„ä¾‹: è²¬ä»»ã®æ˜ç¢ºãªåˆ†é›¢
app/services/
â”œâ”€â”€ slack_notifier.rb          # Slacké€šçŸ¥ã®è²¬å‹™
â”œâ”€â”€ slack/message_builder.rb   # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹ç¯‰ã®è²¬å‹™
â”œâ”€â”€ smarthr/client.rb          # APIé€šä¿¡ã®è²¬å‹™
â””â”€â”€ smarthr/employee_syncer.rb # åŒæœŸãƒ­ã‚¸ãƒƒã‚¯ã®è²¬å‹™
```

#### 2. ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ã®å®šç¾©
```ruby
# è‰¯ã„ä¾‹: çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
class ApplicationError < StandardError
  attr_reader :status_code, :error_code
  # ...
end
```

#### 3. ã‚¹ã‚³ãƒ¼ãƒ—ã®é©åˆ‡ãªæ´»ç”¨
```ruby
# è‰¯ã„ä¾‹: å†åˆ©ç”¨å¯èƒ½ãªã‚¯ã‚¨ãƒªãƒ­ã‚¸ãƒƒã‚¯
scope :active, -> { where(is_active: true) }
scope :visible_to_visitors, -> { where(visible_to_visitors: true) }
scope :by_department, ->(dept_id) { where(department_id: dept_id) if dept_id.present? }
```

#### 4. éåŒæœŸã‚¸ãƒ§ãƒ–ã®æ´»ç”¨
```ruby
# è‰¯ã„ä¾‹: ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥ã®å®Ÿè£…
retry_on SlackNotifier::NotificationFailedError, 
         wait: :exponentially_longer, 
         attempts: 3
```

### âŒ æ”¹å–„ãŒå¿…è¦ãªç‚¹

#### 1. Visitãƒ¢ãƒ‡ãƒ«ã®é‡è¤‡ã‚³ãƒ¼ãƒ‰
```ruby
# å•é¡Œ: enumã®çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒé‡è¤‡
def pending?
  status == "pending"  # enumãŒæ—¢ã«æä¾›ã—ã¦ã„ã‚‹
end

# Railsã®enumã¯è‡ªå‹•çš„ã«`pending?`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ä¸è¦
```

#### 2. ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã¨ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
```ruby
# å•é¡Œ: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸå€¤
text: "11éšã«#{@employee.name}ã•ã‚“ã¸ã®æ¥å®¢ãŒã‚ã‚Šã¾ã™ã€‚"  # 11éšãŒå›ºå®š

# å•é¡Œ: å›ºå®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼åç”Ÿæˆ
"https://ui-avatars.com/api/?name=#{...}&background=random"  # UIç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹ã«ä¾å­˜
```

#### 3. N+1ã‚¯ã‚¨ãƒªã®æ‡¸å¿µ
```ruby
# VisitsController#create
# employeeã¨departmentã®é–¢é€£ãŒé©åˆ‡ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹è¦ç¢ºèª
```

---

## é‡å¤§ãªå•é¡Œ

### ğŸ”´ CRITICAL: AppConfigæœªå®šç¾©

**å•é¡Œã®è©³ç´°**:
ã‚³ãƒ¼ãƒ‰å…¨ä½“ã§`AppConfig::Slack`ã€`AppConfig::SmartHR`ãªã©ã‚’å‚ç…§ã—ã¦ã„ã‚‹ãŒã€å®šç¾©ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€‚

**å½±éŸ¿**:
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ·å‹•ã—ãªã„
- ã™ã¹ã¦ã®Slack/SmartHRé€£æºãŒå‹•ä½œã—ãªã„

**å ´æ‰€**:
```ruby
# æœªå®šç¾©ã®ã¾ã¾ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ç®‡æ‰€
app/services/slack_notifier.rb:9
app/services/slack/message_builder.rb:88
app/services/smarthr/client.rb:12
# ä»–å¤šæ•°...
```

**è§£æ±ºç­–**: ä»¥ä¸‹ã®ã‚ˆã†ãªè¨­å®šã‚¯ãƒ©ã‚¹ã‚’ä½œæˆ

```ruby
# config/initializers/app_config.rb
module AppConfig
  module Slack
    class << self
      def bot_token
        ENV.fetch("SLACK_BOT_TOKEN", nil)
      end
      
      def bot_token?
        bot_token.present?
      end
      
      def channel_id
        ENV.fetch("SLACK_CHANNEL_ID", nil)
      end
      
      def channel_id?
        channel_id.present?
      end
      
      def signing_secret
        ENV.fetch("SLACK_SIGNING_SECRET", nil)
      end
    end
    
    # ã‚¢ã‚¯ã‚·ãƒ§ãƒ³IDå®šæ•°
    ACTION_GOING_NOW = "visit_going_now"
    ACTION_WAITING = "visit_waiting"
    ACTION_NO_MATCH = "visit_no_match"
    
    PAYLOAD_TYPE_BLOCK_ACTIONS = "block_actions"
  end
  
  module SmartHR
    class << self
      def subdomain
        ENV.fetch("SMARTHR_SUBDOMAIN", nil)
      end
      
      def access_token
        ENV.fetch("SMARTHR_ACCESS_TOKEN", nil)
      end
    end
    
    DEFAULT_PER_PAGE = 100
    MAX_RETRY_COUNT = 3
    RETRY_INTERVAL = 1
    RETRY_BACKOFF_FACTOR = 2
  end
  
  module Timeout
    SMARTHR_API_TIMEOUT = 30
    SMARTHR_API_OPEN_TIMEOUT = 10
    SLACK_API_TIMEOUT = 10
  end
end
```

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ”¹å–„ææ¡ˆ

### 1. è¨­å®šç®¡ç†ã®ä¸€å…ƒåŒ–

#### ç¾çŠ¶ã®å•é¡Œ
- ç’°å¢ƒå¤‰æ•°ãŒæ•£åœ¨
- ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ãŒã‚³ãƒ¼ãƒ‰å†…ã«åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹
- è¨­å®šã®å¤‰æ›´ãŒå›°é›£

#### ææ¡ˆ: Dry-Configurableã®å°å…¥

```ruby
# Gemfile
gem 'dry-configurable'

# config/initializers/app_settings.rb
require 'dry/configurable'

class AppSettings
  extend Dry::Configurable
  
  setting :reception_floor, default: "11éš"
  setting :company_name, default: "æ ªå¼ä¼šç¤¾ã‚µãƒ³ãƒ—ãƒ«"
  
  setting :slack do
    setting :bot_token, constructor: -> (value) { ENV.fetch("SLACK_BOT_TOKEN", value) }
    setting :channel_id, constructor: -> (value) { ENV.fetch("SLACK_CHANNEL_ID", value) }
    setting :signing_secret, constructor: -> (value) { ENV.fetch("SLACK_SIGNING_SECRET", value) }
    setting :timeout, default: 10
  end
  
  setting :smarthr do
    setting :subdomain, constructor: -> (value) { ENV.fetch("SMARTHR_SUBDOMAIN", value) }
    setting :access_token, constructor: -> (value) { ENV.fetch("SMARTHR_ACCESS_TOKEN", value) }
    setting :per_page, default: 100
    setting :timeout, default: 30
  end
end

# ä½¿ç”¨ä¾‹
AppSettings.config.reception_floor # => "11éš"
AppSettings.config.slack.bot_token # => ENV["SLACK_BOT_TOKEN"]
```

### 2. Repository ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å°å…¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

å¤§è¦æ¨¡åŒ–ã‚’è¦‹è¶Šã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤ã‚’æŠ½è±¡åŒ–

```ruby
# app/repositories/employee_repository.rb
class EmployeeRepository
  class << self
    def find_active_by_department(department_id, search_query: nil)
      scope = Employee.active
                      .visible_to_visitors
                      .includes(:department)
                      .by_department(department_id)
      
      scope = scope.search(search_query) if search_query.present?
      scope.ordered
    end
    
    def find_with_visit_stats(employee_id)
      Employee.includes(:visits)
              .where(id: employee_id)
              .select('employees.*, COUNT(visits.id) as visits_count')
              .group('employees.id')
              .first
    end
    
    def sync_from_smarthr(smarthr_data)
      # åŒæœŸãƒ­ã‚¸ãƒƒã‚¯ã‚’Repositoryã«é›†ç´„
    end
  end
end

# ä½¿ç”¨ä¾‹
employees = EmployeeRepository.find_active_by_department(params[:department_id])
```

### 3. Form Object ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å°å…¥

è¤‡é›‘ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚„è¤‡æ•°ãƒ¢ãƒ‡ãƒ«ã«ã¾ãŸãŒã‚‹å‡¦ç†ã‚’åˆ†é›¢

```ruby
# app/forms/visit_creation_form.rb
class VisitCreationForm
  include ActiveModel::Model
  include ActiveModel::Attributes
  
  attribute :employee_id, :integer
  attribute :notes, :string
  attribute :visitor_name, :string
  attribute :visitor_company, :string
  
  validates :employee_id, presence: true
  validates :visitor_name, presence: true, if: -> { visitor_info_required? }
  validates :notes, length: { maximum: 500 }
  
  def save
    return false unless valid?
    
    ActiveRecord::Base.transaction do
      @visit = Visit.create!(
        employee_id: employee_id,
        notes: notes
      )
      
      # è¿½åŠ ã®å‡¦ç†ï¼ˆãƒ­ã‚°è¨˜éŒ²ãªã©ï¼‰
      
      @visit
    end
  end
  
  private
  
  def visitor_info_required?
    # ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«å¿œã˜ãŸåˆ¤å®š
    AppSettings.config.require_visitor_info
  end
end
```

### 4. ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®éƒ¨åˆ†å°å…¥

Slacké€šçŸ¥ã‚„ãƒ­ã‚°è¨˜éŒ²ãªã©ã®å‰¯ä½œç”¨ã‚’ç–çµåˆã«

```ruby
# app/events/visit_created_event.rb
class VisitCreatedEvent
  attr_reader :visit
  
  def initialize(visit)
    @visit = visit
  end
end

# app/subscribers/slack_notification_subscriber.rb
class SlackNotificationSubscriber
  def call(event)
    SlackNotificationJob.perform_later(event.visit.id)
  end
end

# app/subscribers/visit_log_subscriber.rb
class VisitLogSubscriber
  def call(event)
    Rails.logger.info "Visit created: #{event.visit.id} for employee #{event.visit.employee.name}"
  end
end

# config/initializers/event_subscribers.rb
Rails.application.config.after_initialize do
  ActiveSupport::Notifications.subscribe("visit.created") do |*args|
    event = ActiveSupport::Notifications::Event.new(*args)
    visit = event.payload[:visit]
    
    SlackNotificationSubscriber.new.call(VisitCreatedEvent.new(visit))
    VisitLogSubscriber.new.call(VisitCreatedEvent.new(visit))
  end
end

# ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰ç™ºè¡Œ
class Visit < ApplicationRecord
  after_create :publish_created_event
  
  private
  
  def publish_created_event
    ActiveSupport::Notifications.instrument("visit.created", visit: self)
  end
end
```

### 5. API ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥

å°†æ¥ã®APIæä¾›ã‚’è¦‹è¶Šã—ãŸæ§‹é€ åŒ–

```ruby
# app/controllers/api/v1/base_controller.rb
module Api
  module V1
    class BaseController < ActionController::API
      include ActionController::HttpAuthentication::Token::ControllerMethods
      
      before_action :authenticate
      
      rescue_from ActiveRecord::RecordNotFound, with: :not_found
      rescue_from ApplicationError, with: :handle_application_error
      
      private
      
      def authenticate
        authenticate_or_request_with_http_token do |token, options|
          # APIèªè¨¼ãƒ­ã‚¸ãƒƒã‚¯
          ApiKey.exists?(token: token, revoked_at: nil)
        end
      end
      
      def handle_application_error(error)
        render json: {
          error: {
            code: error.error_code,
            message: error.message
          }
        }, status: error.status_code
      end
    end
  end
end

# app/controllers/api/v1/visits_controller.rb
module Api
  module V1
    class VisitsController < BaseController
      def create
        form = VisitCreationForm.new(visit_params)
        
        if form.save
          render json: VisitSerializer.new(form.visit), status: :created
        else
          render json: { errors: form.errors }, status: :unprocessable_entity
        end
      end
      
      private
      
      def visit_params
        params.require(:visit).permit(:employee_id, :notes, :visitor_name)
      end
    end
  end
end
```

---

## ã‚³ãƒ¼ãƒ‰å“è³ªæ”¹å–„ææ¡ˆ

### 1. Visitãƒ¢ãƒ‡ãƒ«ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

#### å•é¡Œç‚¹
- enumã®çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ãŒé‡è¤‡
- `status_text`ãƒ¡ã‚½ãƒƒãƒ‰ã®é‡è¤‡å®šç¾©

#### æ”¹å–„å¾Œ
```ruby
class Visit < ApplicationRecord
  belongs_to :employee
  
  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å®šç¾©
  enum :status, {
    pending: "pending",
    going_now: "going_now",
    waiting: "waiting",
    no_match: "no_match"
  }, prefix: true
  
  validates :status, presence: true
  validates :employee, presence: true
  
  # ã‚¹ã‚³ãƒ¼ãƒ—
  scope :recent, -> { order(created_at: :desc) }
  scope :today, -> { where(created_at: Time.zone.now.beginning_of_day..) }
  scope :this_week, -> { where(created_at: Time.zone.now.beginning_of_week..) }
  scope :responded, -> { where.not(status: :pending) }
  
  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆå®šæ•°åŒ–ï¼‰
  STATUS_TEXTS = {
    "pending" => "ç¢ºèªå¾…ã¡",
    "going_now" => "ã™ãè¡Œãã¾ã™",
    "waiting" => "ãŠå¾…ã¡ã„ãŸã ã",
    "no_match" => "å¿ƒå½“ãŸã‚ŠãŒãªã„"
  }.freeze
  
  # responded?ã¯enumã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨
  def responded?
    !status_pending?
  end
  
  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã®å–å¾—
  def status_text
    STATUS_TEXTS.fetch(status, "ç¢ºèªæ¸ˆã¿")
  end
  
  # ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ç‰ˆï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
  def self.status_text_for(status_value)
    STATUS_TEXTS.fetch(status_value.to_s, "ç¢ºèªæ¸ˆã¿")
  end
  
  # è¡¨ç¤ºç”¨ãƒ¡ã‚½ãƒƒãƒ‰
  def formatted_created_at
    I18n.l(created_at, format: :long) # i18nå¯¾å¿œ
  end
end
```

### 2. Employeeãƒ¢ãƒ‡ãƒ«ã®æ”¹å–„

```ruby
class Employee < ApplicationRecord
  belongs_to :department
  has_many :visits, dependent: :restrict_with_error
  
  # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  validates :name, presence: true, length: { maximum: 100 }
  validates :slack_user_id, 
            presence: true, 
            uniqueness: { case_sensitive: true },
            format: { 
              with: /\A[A-Z0-9_]+\z/, 
              message: :invalid_slack_user_id 
            }
  validates :email, 
            uniqueness: { case_sensitive: false }, 
            allow_nil: true,
            format: { 
              with: URI::MailTo::EMAIL_REGEXP, 
              allow_blank: true 
            }
  validates :department, presence: true
  
  # ã‚¹ã‚³ãƒ¼ãƒ—ã®æ”¹å–„
  scope :active, -> { where(is_active: true) }
  scope :inactive, -> { where(is_active: false) }
  scope :visible_to_visitors, -> { where(visible_to_visitors: true) }
  scope :hidden_from_visitors, -> { where(visible_to_visitors: false) }
  scope :by_department, ->(dept_id) { where(department_id: dept_id) if dept_id.present? }
  scope :search, ->(query) { 
    sanitized = sanitize_sql_like(query)
    where("name LIKE :query OR email LIKE :query", query: "%#{sanitized}%") if query.present?
  }
  scope :recent, -> { order(created_at: :desc) }
  scope :ordered, -> { joins(:department).merge(Department.ordered).order(:name) }
  scope :synced_from_smarthr, -> { where.not(smarthr_id: nil) }
  scope :not_synced_from_smarthr, -> { where(smarthr_id: nil) }
  
  # Concernã«æŠ½å‡ºå¯èƒ½
  scope :with_visit_stats, -> {
    left_joins(:visits)
      .select('employees.*, COUNT(visits.id) as visits_count')
      .group('employees.id')
  }
  
  # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
  after_initialize :set_default_avatar_url, if: :new_record?
  before_validation :normalize_email
  
  # ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
  def display_name
    is_active? ? name : "#{name}ï¼ˆç„¡åŠ¹ï¼‰"
  end
  
  def full_info
    "#{name} (#{department.name})"
  end
  
  # Slacké€šçŸ¥å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
  def notifiable?
    is_active? && slack_user_id.present? && slack_user_id_valid?
  end
  
  private
  
  def set_default_avatar_url
    self.avatar_url ||= generate_avatar_url
  end
  
  def generate_avatar_url
    # ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹ã«å§”è­²ã™ã‚‹æ–¹ãŒè‰¯ã„
    AvatarUrlGenerator.generate(name)
  end
  
  def normalize_email
    self.email = email.downcase.strip if email.present?
  end
  
  def slack_user_id_valid?
    # ã‚ˆã‚Šå³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    slack_user_id.match?(/\A[A-Z][A-Z0-9]{8,10}\z/)
  end
end

# app/services/avatar_url_generator.rb
class AvatarUrlGenerator
  DEFAULT_SERVICE = "ui-avatars.com"
  
  class << self
    def generate(name, service: DEFAULT_SERVICE)
      case service
      when "ui-avatars.com"
        generate_ui_avatars_url(name)
      when "gravatar"
        generate_gravatar_url(name)
      else
        default_avatar_url
      end
    end
    
    private
    
    def generate_ui_avatars_url(name)
      encoded_name = ERB::Util.url_encode(name.to_s)
      "https://ui-avatars.com/api/?name=#{encoded_name}&background=random&size=200"
    end
    
    def generate_gravatar_url(email)
      hash = Digest::MD5.hexdigest(email.to_s.downcase)
      "https://www.gravatar.com/avatar/#{hash}?d=identicon&s=200"
    end
    
    def default_avatar_url
      "/assets/default_avatar.png"
    end
  end
end
```

### 3. SlackNotifierã®æ”¹å–„

```ruby
# app/services/slack_notifier.rb
class SlackNotifier
  class NotConfiguredError < StandardError; end
  class NotificationFailedError < StandardError; end
  
  def initialize(client: nil)
    validate_configuration!
    @client = client || build_client
  end
  
  def notify_visit(visit)
    message_builder = Slack::MessageBuilder.new(visit)
    
    log_notification_start(visit)
    
    response = send_message_to_channel(message_builder)
    save_message_timestamp(visit, response)
    log_notification_success(visit)
    
    response
  rescue ::Slack::Web::Api::Errors::SlackError => e
    handle_slack_error(e)
  rescue StandardError => e
    handle_unexpected_error(e)
  end
  
  def update_message(visit, responder: nil, responded_at: nil)
    message_builder = Slack::MessageBuilder.new(
      visit, 
      responder: responder, 
      responded_at: responded_at
    )
    
    log_message_update_start(visit)
    
    response = @client.chat_update(
      channel: channel_id,
      ts: visit.slack_message_ts,
      text: message_builder.build_plain_text,
      blocks: message_builder.build_notification_blocks
    )
    
    log_message_update_success(visit)
    response
  rescue ::Slack::Web::Api::Errors::SlackError => e
    handle_slack_error(e)
  rescue StandardError => e
    handle_unexpected_error(e)
  end
  
  private
  
  def build_client
    ::Slack::Web::Client.new(token: bot_token)
  end
  
  def validate_configuration!
    raise NotConfiguredError, "SLACK_BOT_TOKEN is not configured" unless bot_token.present?
    raise NotConfiguredError, "SLACK_CHANNEL_ID is not configured" unless channel_id.present?
  end
  
  def bot_token
    @bot_token ||= AppSettings.config.slack.bot_token
  end
  
  def channel_id
    @channel_id ||= AppSettings.config.slack.channel_id
  end
  
  def send_message_to_channel(message_builder)
    blocks = message_builder.build_notification_blocks
    
    log_blocks(blocks) if Rails.env.development?
    
    @client.chat_postMessage(
      channel: channel_id,
      text: message_builder.build_plain_text,
      blocks: blocks
    )
  end
  
  def save_message_timestamp(visit, response)
    return unless response["ok"]
    
    visit.update_column(:slack_message_ts, response["ts"])
  end
  
  # ãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤ã‚’Loggerãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŠ½å‡º
  include SlackNotifierLogger
  
  # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’ErrorHandlerãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŠ½å‡º
  include SlackNotifierErrorHandler
end

# app/services/concerns/slack_notifier_logger.rb
module SlackNotifierLogger
  extend ActiveSupport::Concern
  
  private
  
  def log_notification_start(visit)
    Rails.logger.info(
      "Sending Slack notification",
      visit_id: visit.id,
      channel: channel_id,
      employee: visit.employee.name
    )
  end
  
  def log_notification_success(visit)
    Rails.logger.info(
      "Slack notification sent successfully",
      visit_id: visit.id
    )
  end
  
  def log_blocks(blocks)
    Rails.logger.debug "Slack blocks: #{JSON.pretty_generate(blocks)}"
  end
  
  # ä»–ã®ãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰...
end
```

### 4. SmartHR Syncerã®æ”¹å–„

```ruby
# app/services/smarthr/employee_syncer.rb
module Smarthr
  class EmployeeSyncer
    attr_reader :stats, :errors
    
    def initialize(client: nil)
      @client = client || Smarthr::Client.new
      @stats = SyncStats.new
      @errors = []
    end
    
    def sync_all
      log_sync_start
      
      ActiveRecord::Base.transaction do
        smarthr_employees = fetch_employees
        
        sync_employees(smarthr_employees)
        deactivate_missing_employees(smarthr_employees.map { |e| e[:id] })
      end
      
      log_sync_completion
      create_sync_log
      
      @stats
    rescue Smarthr::Client::ApiError, Smarthr::Client::ConfigurationError => e
      handle_sync_error(e)
      raise
    end
    
    private
    
    def fetch_employees
      employees = @client.fetch_all_employees
      log_fetch_completion(employees.size)
      employees
    end
    
    def sync_employees(smarthr_employees)
      smarthr_employees.each do |smarthr_emp|
        sync_employee(smarthr_emp)
      rescue StandardError => e
        record_employee_error(smarthr_emp[:id], e)
      end
    end
    
    def sync_employee(smarthr_emp)
      EmployeeSyncService.new(smarthr_emp, @stats).call
    end
    
    def deactivate_missing_employees(smarthr_ids)
      MissingEmployeeDeactivator.new(smarthr_ids, @stats).call
    end
    
    def create_sync_log
      SyncLog.create!(
        service: "smarthr",
        status: @errors.empty? ? "success" : "partial_success",
        details: @stats.to_h,
        error_message: @errors.join("\n"),
        synced_at: Time.current
      )
    end
    
    def record_employee_error(employee_id, error)
      error_msg = "Employee #{employee_id}: #{error.message}"
      @errors << error_msg
      @stats.increment_errors
      Rails.logger.error error_msg
    end
    
    # ãƒ­ã‚®ãƒ³ã‚°ãƒ¡ã‚½ãƒƒãƒ‰
    def log_sync_start
      Rails.logger.info "Starting SmartHR employee sync..."
    end
    
    def log_fetch_completion(count)
      Rails.logger.info "Fetched #{count} employees from SmartHR"
    end
    
    def log_sync_completion
      Rails.logger.info "SmartHR sync completed: #{@stats}"
    end
    
    def handle_sync_error(error)
      @errors << error.message
      Rails.logger.error "SmartHR sync failed: #{error.message}"
    end
  end
  
  # app/services/smarthr/sync_stats.rb
  class SyncStats
    attr_reader :created, :updated, :deactivated, :skipped, :errors
    
    def initialize
      @created = 0
      @updated = 0
      @deactivated = 0
      @skipped = 0
      @errors = 0
    end
    
    def increment_created
      @created += 1
    end
    
    def increment_updated
      @updated += 1
    end
    
    def increment_deactivated
      @deactivated += 1
    end
    
    def increment_skipped
      @skipped += 1
    end
    
    def increment_errors
      @errors += 1
    end
    
    def to_h
      {
        created: @created,
        updated: @updated,
        deactivated: @deactivated,
        skipped: @skipped,
        errors: @errors
      }
    end
    
    def to_s
      "Created: #{@created}, Updated: #{@updated}, " \
      "Deactivated: #{@deactivated}, Skipped: #{@skipped}, " \
      "Errors: #{@errors}"
    end
  end
  
  # app/services/smarthr/employee_sync_service.rb
  class EmployeeSyncService
    def initialize(smarthr_employee, stats)
      @smarthr_emp = smarthr_employee
      @stats = stats
    end
    
    def call
      ActiveRecord::Base.transaction do
        department = find_or_create_department
        employee = find_employee
        
        if employee
          update_employee(employee, department)
        else
          create_employee(department)
        end
      end
    end
    
    private
    
    def find_employee
      Employee.find_by(smarthr_id: @smarthr_emp[:id])
    end
    
    def find_or_create_department
      dept_name = DepartmentNameExtractor.extract(@smarthr_emp)
      Department.find_or_create_by!(name: dept_name)
    end
    
    def update_employee(employee, department)
      params = build_employee_params(department)
      
      if employee_changed?(employee, params)
        employee.update!(params)
        @stats.increment_updated
        log_update(employee)
      else
        @stats.increment_skipped
        log_skip(employee)
      end
    end
    
    def create_employee(department)
      params = build_employee_params(department).merge(
        smarthr_id: @smarthr_emp[:id],
        visible_to_visitors: false  # æ–°è¦ã¯éè¡¨ç¤º
      )
      
      employee = Employee.create!(params)
      @stats.increment_created
      log_create(employee)
    end
    
    def build_employee_params(department)
      {
        name: NameBuilder.build(@smarthr_emp),
        email: @smarthr_emp[:email],
        department: department,
        is_active: @smarthr_emp[:emp_status] != "resigned",
        slack_user_id: SlackUserIdResolver.resolve(@smarthr_emp)
      }
    end
    
    def employee_changed?(employee, params)
      employee.name != params[:name] ||
        employee.email != params[:email] ||
        employee.department_id != params[:department]&.id ||
        employee.is_active != params[:is_active]
    end
    
    # ãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰
    def log_update(employee)
      Rails.logger.info "Updated employee: #{employee.name} (SmartHR ID: #{employee.smarthr_id})"
    end
    
    def log_skip(employee)
      Rails.logger.debug "Skipped employee (no changes): #{employee.name}"
    end
    
    def log_create(employee)
      Rails.logger.info "Created employee: #{employee.name} (SmartHR ID: #{employee.smarthr_id})"
    end
  end
end
```

### 5. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®æ”¹å–„

```ruby
# app/controllers/visits_controller.rb
class VisitsController < ApplicationController
  before_action :set_employee, only: [:new]
  
  def new
    @visit = Visit.new(employee: @employee)
  end
  
  def create
    result = CreateVisitService.call(visit_params, session: session)
    
    if result.success?
      redirect_to complete_path, notice: t(".success")
    else
      handle_creation_failure(result)
    end
  end
  
  def complete
    @visit = find_last_visit
  end
  
  def status
    @visit = Visit.includes(:employee).find(params[:id])
    render json: VisitStatusSerializer.new(@visit).as_json
  rescue ActiveRecord::RecordNotFound
    render json: { error: t(".not_found") }, status: :not_found
  end
  
  private
  
  def set_employee
    @employee = Employee.active.visible_to_visitors.find(params[:employee_id])
  rescue ActiveRecord::RecordNotFound
    redirect_to root_path, alert: t(".employee_not_found")
  end
  
  def find_last_visit
    return nil unless session[:last_visit_id]
    
    Visit.find(session[:last_visit_id])
  rescue ActiveRecord::RecordNotFound
    nil
  end
  
  def handle_creation_failure(result)
    @employee = Employee.find_by(id: visit_params[:employee_id])
    flash.now[:alert] = result.error_message
    render :new, status: result.status_code
  end
  
  def visit_params
    params.require(:visit).permit(:employee_id, :notes)
  end
end

# app/services/create_visit_service.rb
class CreateVisitService
  Result = Struct.new(:success?, :visit, :error_message, :status_code, keyword_init: true)
  
  class << self
    def call(params, session:)
      new(params, session).call
    end
  end
  
  def initialize(params, session)
    @params = params
    @session = session
  end
  
  def call
    ActiveRecord::Base.transaction do
      visit = Visit.create!(
        employee_id: @params[:employee_id],
        notes: @params[:notes]
      )
      
      @session[:last_visit_id] = visit.id
      
      # éåŒæœŸã§Slacké€šçŸ¥
      SlackNotificationJob.perform_later(visit.id)
      
      success_result(visit)
    end
  rescue ActiveRecord::RecordInvalid => e
    validation_error_result(e)
  rescue SlackNotifier::NotConfiguredError => e
    configuration_error_result(e)
  rescue StandardError => e
    unexpected_error_result(e)
  end
  
  private
  
  def success_result(visit)
    Result.new(
      success?: true,
      visit: visit,
      error_message: nil,
      status_code: :ok
    )
  end
  
  def validation_error_result(error)
    Rails.logger.error "Visit validation failed: #{error.message}"
    Result.new(
      success?: false,
      visit: nil,
      error_message: I18n.t("visits.create.validation_error"),
      status_code: :unprocessable_entity
    )
  end
  
  def configuration_error_result(error)
    Rails.logger.error "Slack not configured: #{error.message}"
    Result.new(
      success?: false,
      visit: nil,
      error_message: I18n.t("visits.create.configuration_error"),
      status_code: :internal_server_error
    )
  end
  
  def unexpected_error_result(error)
    Rails.logger.error "Unexpected error: #{error.class.name} - #{error.message}"
    Rails.logger.error error.backtrace.join("\n")
    Result.new(
      success?: false,
      visit: nil,
      error_message: I18n.t("visits.create.unexpected_error"),
      status_code: :internal_server_error
    )
  end
end

# app/serializers/visit_status_serializer.rb
class VisitStatusSerializer
  def initialize(visit)
    @visit = visit
  end
  
  def as_json
    {
      id: @visit.id,
      status: @visit.status,
      status_text: @visit.status_text,
      responded: @visit.responded?,
      employee: {
        id: @visit.employee.id,
        name: @visit.employee.name,
        department: @visit.employee.department.name
      },
      created_at: @visit.created_at.iso8601,
      updated_at: @visit.updated_at.iso8601
    }
  end
end
```

---

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ”¹å–„

### 1. SQL Injectionå¯¾ç­–ã®å¼·åŒ–

```ruby
# ç¾çŠ¶ï¼ˆè„†å¼±æ€§ã‚ã‚Šï¼‰
scope :search, ->(query) { 
  where("name LIKE ?", "%#{sanitize_sql_like(query)}%") if query.present? 
}

# æ”¹å–„å¾Œï¼ˆã‚ˆã‚Šå®‰å…¨ï¼‰
scope :search, ->(query) {
  return none if query.blank?
  
  sanitized = sanitize_sql_like(query.to_s)
  where("name LIKE :query OR email LIKE :query", query: "%#{sanitized}%")
}

# ã•ã‚‰ã«è‰¯ã„æ–¹æ³•: Arelä½¿ç”¨
scope :search, ->(query) {
  return none if query.blank?
  
  sanitized = sanitize_sql_like(query.to_s)
  name_matches = arel_table[:name].matches("%#{sanitized}%")
  email_matches = arel_table[:email].matches("%#{sanitized}%")
  where(name_matches.or(email_matches))
}
```

### 2. CSRFå¯¾ç­–ã®å¼·åŒ–

```ruby
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  # CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ˜ãƒƒãƒ€ãƒ¼ã«è¨­å®šï¼ˆSPAå¯¾å¿œï¼‰
  after_action :set_csrf_cookie
  
  private
  
  def set_csrf_cookie
    cookies["CSRF-TOKEN"] = {
      value: form_authenticity_token,
      same_site: :strict,
      secure: Rails.env.production?
    }
  end
end

# Slack Webhookç”¨ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã¯CSRFã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ãŒã€
# ä»£ã‚ã‚Šã«Slackç½²åæ¤œè¨¼ã‚’å¿…é ˆã«
class SlackActionsController < ApplicationController
  skip_before_action :verify_authenticity_token
  before_action :verify_slack_signature  # å¿…é ˆ
  
  private
  
  def verify_slack_signature
    verifier = SlackSignatureVerifier.new(skip_in_development: false)  # é–‹ç™ºç’°å¢ƒã§ã‚‚æ¤œè¨¼
    verifier.verify(request)
  rescue SlackSignatureError => e
    Rails.logger.error "Slack signature verification failed: #{e.message}"
    head :unauthorized
  end
end
```

### 3. ç’°å¢ƒå¤‰æ•°ã®æš—å·åŒ–

```ruby
# config/initializers/encrypted_credentials.rb
# Rails 7.1+ã®encrypted credentialsã‚’æ´»ç”¨

# ä½¿ç”¨ä¾‹
Rails.application.credentials.dig(:slack, :bot_token)
Rails.application.credentials.dig(:smarthr, :access_token)

# config/credentials/production.yml.enc ã«ä¿å­˜
# EDITOR="vim" rails credentials:edit --environment production
```

### 4. Rate Limiting ã®å°å…¥

```ruby
# Gemfile
gem 'rack-attack'

# config/initializers/rack_attack.rb
class Rack::Attack
  # è¨ªå•è€…ã‹ã‚‰ã®å—ä»˜ç”³è«‹ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™
  throttle('visits/ip', limit: 10, period: 60.seconds) do |req|
    req.ip if req.path == '/visits' && req.post?
  end
  
  # Slack Webhookã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼ˆå¿µã®ãŸã‚ï¼‰
  throttle('slack_webhook/ip', limit: 100, period: 60.seconds) do |req|
    req.ip if req.path == '/slack/actions' && req.post?
  end
  
  # ç®¡ç†ç”»é¢ã®ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå›æ•°åˆ¶é™
  throttle('admin_login/email', limit: 5, period: 60.seconds) do |req|
    if req.path == '/admin/login' && req.post?
      req.params['email'].to_s.downcase.presence
    end
  end
  
  # ãƒ–ãƒ­ãƒƒã‚¯æ™‚ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
  self.blocklisted_responder = lambda do |request|
    [429, {'Content-Type' => 'application/json'}, [{
      error: 'Too Many Requests',
      message: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤šã™ãã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
    }.to_json]]
  end
end
```

### 5. ç®¡ç†ç”»é¢ã®èªè¨¼å¼·åŒ–

```ruby
# app/controllers/admin/base_controller.rb
module Admin
  class BaseController < ApplicationController
    before_action :authenticate_admin
    before_action :check_admin_session_timeout
    after_action :update_session_timestamp
    
    private
    
    def authenticate_admin
      unless current_admin
        redirect_to admin_login_path, alert: "ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™"
      end
    end
    
    def current_admin
      return @current_admin if defined?(@current_admin)
      
      @current_admin = AdminUser.find_by(id: session[:admin_id]) if session[:admin_id]
    end
    helper_method :current_admin
    
    def check_admin_session_timeout
      if session_expired?
        reset_session
        redirect_to admin_login_path, alert: "ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒæœŸé™åˆ‡ã‚Œã§ã™ã€‚å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚"
      end
    end
    
    def session_expired?
      return false unless session[:last_activity_at]
      
      Time.current - session[:last_activity_at].to_time > 30.minutes
    end
    
    def update_session_timestamp
      session[:last_activity_at] = Time.current
    end
  end
end

# 2è¦ç´ èªè¨¼ã®è¿½åŠ ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
# Gemfile
gem 'devise'
gem 'devise-two-factor'
gem 'rqrcode'
```

---

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 1. N+1ã‚¯ã‚¨ãƒªã®è§£æ±º

```ruby
# app/controllers/employees_controller.rb
class EmployeesController < ApplicationController
  def index
    @departments = Department.ordered
                             .includes(:employees)  # N+1è§£æ¶ˆ
                             .with_active_employees
    
    @employees = Employee.active
                         .visible_to_visitors
                         .includes(:department)  # N+1è§£æ¶ˆ
                         .by_department(params[:department_id])
                         .search(params[:query])
                         .ordered
  end
end

# app/controllers/admin/employees_controller.rb
module Admin
  class EmployeesController < BaseController
    def index
      @employees = Employee.includes(:department)  # N+1è§£æ¶ˆ
                           .with_visit_count  # ã‚«ã‚¦ãƒ³ãƒˆã‚’äº‹å‰è¨ˆç®—
                           .page(params[:page])
                           .per(25)
    end
  end
end

# app/models/employee.rb
scope :with_visit_count, -> {
  left_joins(:visits)
    .select('employees.*, COUNT(visits.id) as visits_count')
    .group('employees.id')
}
```

### 2. ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥

```ruby
# app/models/department.rb
class Department < ApplicationRecord
  # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  has_many :employees, dependent: :restrict_with_error, counter_cache: true
  
  # ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆãƒ“ãƒ¥ãƒ¼ï¼‰
  def cache_key_with_employees
    [cache_key, employees_count, employees.maximum(:updated_at)].join('/')
  end
end

# app/views/employees/index.html.erb
<% @departments.each do |department| %>
  <% cache department.cache_key_with_employees do %>
    <!-- éƒ¨ç½²ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
  <% end %>
<% end %>

# ãƒ­ã‚·ã‚¢ãƒ³ãƒ‰ãƒ¼ãƒ«ï¼ˆRussian Dollï¼‰ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°
<% cache @employees do %>
  <% @employees.each do |employee| %>
    <% cache employee do %>
      <!-- å¾“æ¥­å“¡ã‚«ãƒ¼ãƒ‰ -->
    <% end %>
  <% end %>
<% end %>
```

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æœ€é©åŒ–

```ruby
# db/migrate/YYYYMMDDHHMMSS_add_performance_indexes.rb
class AddPerformanceIndexes < ActiveRecord::Migration[8.0]
  def change
    # Employeeãƒ†ãƒ¼ãƒ–ãƒ«
    add_index :employees, [:is_active, :visible_to_visitors], 
              name: 'idx_employees_on_active_visible'
    add_index :employees, [:department_id, :is_active], 
              name: 'idx_employees_on_dept_active'
    add_index :employees, :slack_user_id, unique: true
    add_index :employees, :email, unique: true, where: "email IS NOT NULL"
    
    # Visitãƒ†ãƒ¼ãƒ–ãƒ«
    add_index :visits, [:employee_id, :created_at], 
              name: 'idx_visits_on_employee_created'
    add_index :visits, [:status, :created_at], 
              name: 'idx_visits_on_status_created'
    add_index :visits, :slack_message_ts, unique: true, 
              where: "slack_message_ts IS NOT NULL"
    
    # Departmentãƒ†ãƒ¼ãƒ–ãƒ«
    add_index :departments, :position
    
    # è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã‚«ãƒãƒªãƒ³ã‚°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
    add_index :employees, 
              [:is_active, :visible_to_visitors, :department_id, :name], 
              name: 'idx_employees_for_visitor_search'
  end
end
```

### 4. ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–ã®æœ€é©åŒ–

```ruby
# app/jobs/slack_notification_job.rb
class SlackNotificationJob < ApplicationJob
  queue_as :critical  # å„ªå…ˆåº¦ã®é«˜ã„ã‚­ãƒ¥ãƒ¼
  
  # ã‚ˆã‚Šè©³ç´°ãªãƒªãƒˆãƒ©ã‚¤è¨­å®š
  retry_on SlackNotifier::NotificationFailedError,
           wait: :polynomially_longer,  # 1s, 4s, 9s, 16s...
           attempts: 5,
           queue: :default
  
  retry_on Faraday::TimeoutError,
           wait: 5.seconds,
           attempts: 3
  
  # ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã®ã¿ãƒªãƒˆãƒ©ã‚¤
  retry_on ::Slack::Web::Api::Errors::RateLimited,
           wait: ->(executions) { executions * 60 },  # 1åˆ†, 2åˆ†, 3åˆ†...
           attempts: 3
  
  discard_on SlackNotifier::NotConfiguredError
  discard_on ActiveRecord::RecordNotFound
  discard_on ::Slack::Web::Api::Errors::AccountInactive
  
  def perform(visit_id)
    visit = Visit.includes(employee: :department).find(visit_id)
    
    # Slacké€šçŸ¥ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹æ¡ä»¶
    return unless should_send_notification?
    
    notifier = SlackNotifier.new
    notifier.notify_visit(visit)
    
    log_success(visit)
  rescue StandardError => e
    log_failure(visit_id, e)
    raise
  end
  
  private
  
  def should_send_notification?
    AppSettings.config.slack.bot_token.present?
  end
  
  def log_success(visit)
    Rails.logger.info(
      "Slack notification completed",
      visit_id: visit.id,
      employee: visit.employee.name,
      attempts: executions
    )
  end
  
  def log_failure(visit_id, error)
    Rails.logger.error(
      "Slack notification failed",
      visit_id: visit_id,
      error: error.class.name,
      message: error.message,
      attempts: executions
    )
  end
end

# config/initializers/solid_queue.rb
# ã‚­ãƒ¥ãƒ¼ã®å„ªå…ˆåº¦è¨­å®š
Rails.application.configure do
  config.solid_queue.connects_to = { database: { writing: :queue } }
  
  # ãƒ¯ãƒ¼ã‚«ãƒ¼è¨­å®š
  config.solid_queue.workers = [
    {
      queues: "critical",
      threads: 3,
      processes: 2,
      polling_interval: 1
    },
    {
      queues: "default",
      threads: 5,
      processes: 2,
      polling_interval: 5
    },
    {
      queues: "low_priority",
      threads: 2,
      processes: 1,
      polling_interval: 10
    }
  ]
end
```

### 5. ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒšãƒ¼ã‚¸ãƒ³ã‚°ã®æ”¹å–„

```ruby
# Gemfile
gem 'kaminari'  # ã¾ãŸã¯ 'pagy' (ã‚ˆã‚Šè»½é‡)

# app/controllers/admin/employees_controller.rb
def index
  @employees = Employee.includes(:department)
                       .order(created_at: :desc)
                       .page(params[:page])
                       .per(25)
end

# ã‚«ãƒ¼ã‚½ãƒ«ãƒ™ãƒ¼ã‚¹ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå¤§é‡ãƒ‡ãƒ¼ã‚¿å‘ã‘ï¼‰
# Gemfile
gem 'pagy'

# app/controllers/api/v1/visits_controller.rb
def index
  @pagy, @visits = pagy(
    Visit.includes(:employee)
         .where('created_at > ?', params[:after])
         .order(created_at: :desc),
    items: 50
  )
  
  render json: {
    visits: @visits,
    pagy: pagy_metadata(@pagy)
  }
end
```

---

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 1. ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```ruby
# spec/rails_helper.rb
require 'spec_helper'
ENV['RAILS_ENV'] ||= 'test'
require_relative '../config/environment'
abort("Running in production mode!") if Rails.env.production?

require 'rspec/rails'
require 'capybara/rspec'
require 'webmock/rspec'

# FactoryBotã®è¨­å®š
RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
  
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end
  
  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
      example.run
    end
  end
  
  # Slack APIã‚’ãƒ¢ãƒƒã‚¯
  config.before(:each) do
    allow_any_instance_of(SlackNotifier).to receive(:notify_visit)
    WebMock.disable_net_connect!(allow_localhost: true)
  end
end

# spec/support/shared_contexts/with_slack_mocked.rb
RSpec.shared_context 'with slack mocked' do
  let(:slack_client) { instance_double(::Slack::Web::Client) }
  let(:slack_response) { { 'ok' => true, 'ts' => '1234567890.123456' } }
  
  before do
    allow(::Slack::Web::Client).to receive(:new).and_return(slack_client)
    allow(slack_client).to receive(:chat_postMessage).and_return(slack_response)
    allow(slack_client).to receive(:chat_update).and_return(slack_response)
  end
end
```

### 2. ãƒ¢ãƒ‡ãƒ«ãƒ†ã‚¹ãƒˆ

```ruby
# spec/models/employee_spec.rb
require 'rails_helper'

RSpec.describe Employee, type: :model do
  describe 'associations' do
    it { should belong_to(:department) }
    it { should have_many(:visits).dependent(:restrict_with_error) }
  end
  
  describe 'validations' do
    subject { build(:employee) }
    
    it { should validate_presence_of(:name) }
    it { should validate_length_of(:name).is_at_most(100) }
    it { should validate_presence_of(:slack_user_id) }
    it { should validate_uniqueness_of(:slack_user_id).case_sensitive }
    
    context 'slack_user_id format' do
      it 'accepts valid Slack user ID' do
        employee = build(:employee, slack_user_id: 'U1234ABCD')
        expect(employee).to be_valid
      end
      
      it 'rejects invalid Slack user ID' do
        employee = build(:employee, slack_user_id: 'invalid_id')
        expect(employee).not_to be_valid
        expect(employee.errors[:slack_user_id]).to be_present
      end
    end
    
    context 'email format' do
      it 'accepts valid email' do
        employee = build(:employee, email: 'test@example.com')
        expect(employee).to be_valid
      end
      
      it 'rejects invalid email' do
        employee = build(:employee, email: 'invalid_email')
        expect(employee).not_to be_valid
      end
      
      it 'allows nil email' do
        employee = build(:employee, email: nil)
        expect(employee).to be_valid
      end
    end
  end
  
  describe 'scopes' do
    let!(:active_employee) { create(:employee, is_active: true) }
    let!(:inactive_employee) { create(:employee, is_active: false) }
    let!(:visible_employee) { create(:employee, visible_to_visitors: true) }
    let!(:hidden_employee) { create(:employee, visible_to_visitors: false) }
    
    describe '.active' do
      it 'returns only active employees' do
        expect(Employee.active).to include(active_employee)
        expect(Employee.active).not_to include(inactive_employee)
      end
    end
    
    describe '.visible_to_visitors' do
      it 'returns only visible employees' do
        expect(Employee.visible_to_visitors).to include(visible_employee)
        expect(Employee.visible_to_visitors).not_to include(hidden_employee)
      end
    end
    
    describe '.search' do
      let!(:john) { create(:employee, name: 'John Doe') }
      let!(:jane) { create(:employee, name: 'Jane Smith') }
      
      it 'finds employees by name' do
        results = Employee.search('John')
        expect(results).to include(john)
        expect(results).not_to include(jane)
      end
      
      it 'is case insensitive' do
        results = Employee.search('john')
        expect(results).to include(john)
      end
      
      it 'returns all when query is blank' do
        expect(Employee.search('').count).to eq(Employee.count)
      end
    end
  end
  
  describe '#display_name' do
    it 'returns name for active employee' do
      employee = build(:employee, name: 'John Doe', is_active: true)
      expect(employee.display_name).to eq('John Doe')
    end
    
    it 'returns name with inactive marker for inactive employee' do
      employee = build(:employee, name: 'John Doe', is_active: false)
      expect(employee.display_name).to eq('John Doeï¼ˆç„¡åŠ¹ï¼‰')
    end
  end
  
  describe '#notifiable?' do
    it 'returns true for active employee with valid Slack ID' do
      employee = build(:employee, is_active: true, slack_user_id: 'U1234ABCD')
      expect(employee.notifiable?).to be true
    end
    
    it 'returns false for inactive employee' do
      employee = build(:employee, is_active: false, slack_user_id: 'U1234ABCD')
      expect(employee.notifiable?).to be false
    end
  end
  
  describe 'callbacks' do
    describe 'avatar URL generation' do
      it 'sets default avatar URL on create' do
        employee = create(:employee, avatar_url: nil)
        expect(employee.avatar_url).to be_present
      end
      
      it 'does not overwrite existing avatar URL' do
        url = 'https://example.com/avatar.png'
        employee = create(:employee, avatar_url: url)
        expect(employee.avatar_url).to eq(url)
      end
    end
  end
end

# spec/factories/employees.rb
FactoryBot.define do
  factory :employee do
    sequence(:name) { |n| "Employee #{n}" }
    sequence(:email) { |n| "employee#{n}@example.com" }
    sequence(:slack_user_id) { |n| "U#{n.to_s.rjust(9, '0')}" }
    association :department
    is_active { true }
    visible_to_visitors { true }
    
    trait :inactive do
      is_active { false }
    end
    
    trait :hidden do
      visible_to_visitors { false }
    end
    
    trait :with_visits do
      transient do
        visits_count { 3 }
      end
      
      after(:create) do |employee, evaluator|
        create_list(:visit, evaluator.visits_count, employee: employee)
      end
    end
  end
end
```

### 3. ã‚µãƒ¼ãƒ“ã‚¹ãƒ†ã‚¹ãƒˆ

```ruby
# spec/services/slack_notifier_spec.rb
require 'rails_helper'

RSpec.describe SlackNotifier, type: :service do
  include_context 'with slack mocked'
  
  let(:department) { create(:department) }
  let(:employee) { create(:employee, department: department) }
  let(:visit) { create(:visit, employee: employee) }
  
  describe '#notify_visit' do
    context 'when configuration is valid' do
      before do
        allow(AppSettings.config.slack).to receive(:bot_token).and_return('xoxb-test-token')
        allow(AppSettings.config.slack).to receive(:channel_id).and_return('C1234567890')
      end
      
      it 'sends notification successfully' do
        notifier = described_class.new
        response = notifier.notify_visit(visit)
        
        expect(response['ok']).to be true
        expect(slack_client).to have_received(:chat_postMessage)
      end
      
      it 'saves message timestamp' do
        notifier = described_class.new
        notifier.notify_visit(visit)
        
        visit.reload
        expect(visit.slack_message_ts).to eq('1234567890.123456')
      end
    end
    
    context 'when bot token is not configured' do
      before do
        allow(AppSettings.config.slack).to receive(:bot_token).and_return(nil)
      end
      
      it 'raises NotConfiguredError' do
        expect {
          described_class.new
        }.to raise_error(SlackNotifier::NotConfiguredError, /SLACK_BOT_TOKEN/)
      end
    end
    
    context 'when Slack API returns error' do
      before do
        allow(AppSettings.config.slack).to receive(:bot_token).and_return('xoxb-test-token')
        allow(AppSettings.config.slack).to receive(:channel_id).and_return('C1234567890')
        allow(slack_client).to receive(:chat_postMessage)
          .and_raise(::Slack::Web::Api::Errors::ChannelNotFound.new('channel_not_found'))
      end
      
      it 'raises NotificationFailedError' do
        notifier = described_class.new
        
        expect {
          notifier.notify_visit(visit)
        }.to raise_error(SlackNotifier::NotificationFailedError, /channel not found/i)
      end
    end
  end
  
  describe '#update_message' do
    let(:visit) { create(:visit, employee: employee, slack_message_ts: '1234567890.123456') }
    
    before do
      allow(AppSettings.config.slack).to receive(:bot_token).and_return('xoxb-test-token')
      allow(AppSettings.config.slack).to receive(:channel_id).and_return('C1234567890')
    end
    
    it 'updates message successfully' do
      notifier = described_class.new
      response = notifier.update_message(visit, responder: 'Test User')
      
      expect(response['ok']).to be true
      expect(slack_client).to have_received(:chat_update)
    end
  end
end

# spec/services/smarthr/employee_syncer_spec.rb
require 'rails_helper'

RSpec.describe Smarthr::EmployeeSyncer, type: :service do
  let(:client) { instance_double(Smarthr::Client) }
  let(:syncer) { described_class.new(client: client) }
  
  let(:smarthr_employees) do
    [
      {
        id: 'smarthr_123',
        first_name: 'Taro',
        last_name: 'Yamada',
        email: 'taro@example.com',
        emp_status: 'employed',
        department: { name: 'å–¶æ¥­éƒ¨' }
      },
      {
        id: 'smarthr_456',
        first_name: 'Hanako',
        last_name: 'Tanaka',
        email: 'hanako@example.com',
        emp_status: 'employed',
        department: { name: 'é–‹ç™ºéƒ¨' }
      }
    ]
  end
  
  before do
    allow(client).to receive(:fetch_all_employees).and_return(smarthr_employees)
  end
  
  describe '#sync_all' do
    context 'when employees do not exist' do
      it 'creates new employees' do
        expect {
          syncer.sync_all
        }.to change(Employee, :count).by(2)
      end
      
      it 'creates departments' do
        expect {
          syncer.sync_all
        }.to change(Department, :count).by(2)
      end
      
      it 'returns correct stats' do
        stats = syncer.sync_all
        expect(stats[:created]).to eq(2)
        expect(stats[:updated]).to eq(0)
      end
    end
    
    context 'when employees already exist' do
      let!(:department) { create(:department, name: 'å–¶æ¥­éƒ¨') }
      let!(:employee) do
        create(:employee,
               smarthr_id: 'smarthr_123',
               name: 'Yamada Taro',
               department: department)
      end
      
      it 'updates existing employee' do
        syncer.sync_all
        
        employee.reload
        expect(employee.email).to eq('taro@example.com')
      end
      
      it 'returns correct stats' do
        stats = syncer.sync_all
        expect(stats[:created]).to eq(1)  # Hanako
        expect(stats[:updated]).to eq(0)  # Taroã¯å¤‰æ›´ãªã—
        expect(stats[:skipped]).to eq(1)  # Taroã¯ã‚¹ã‚­ãƒƒãƒ—
      end
    end
    
    context 'when employee is missing from SmartHR' do
      let!(:missing_employee) do
        create(:employee, smarthr_id: 'smarthr_999', is_active: true)
      end
      
      it 'deactivates missing employee' do
        syncer.sync_all
        
        missing_employee.reload
        expect(missing_employee.is_active).to be false
      end
      
      it 'returns correct stats' do
        stats = syncer.sync_all
        expect(stats[:deactivated]).to eq(1)
      end
    end
    
    context 'when API error occurs' do
      before do
        allow(client).to receive(:fetch_all_employees)
          .and_raise(Smarthr::Client::ApiError, 'API error')
      end
      
      it 'raises error and records it in stats' do
        expect {
          syncer.sync_all
        }.to raise_error(Smarthr::Client::ApiError)
        
        expect(syncer.errors).to include('API error')
      end
    end
  end
end
```

### 4. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒ†ã‚¹ãƒˆ

```ruby
# spec/requests/visits_spec.rb
require 'rails_helper'

RSpec.describe 'Visits', type: :request do
  include_context 'with slack mocked'
  
  let(:department) { create(:department) }
  let(:employee) { create(:employee, department: department) }
  
  describe 'GET /visits/new' do
    it 'returns success' do
      get new_visit_path(employee_id: employee.id)
      expect(response).to have_http_status(:success)
    end
    
    it 'assigns @visit' do
      get new_visit_path(employee_id: employee.id)
      expect(assigns(:visit)).to be_a_new(Visit)
    end
    
    context 'when employee is not found' do
      it 'redirects to root' do
        get new_visit_path(employee_id: 999999)
        expect(response).to redirect_to(root_path)
      end
    end
  end
  
  describe 'POST /visits' do
    let(:valid_params) do
      {
        visit: {
          employee_id: employee.id,
          notes: 'Test visit'
        }
      }
    end
    
    context 'with valid parameters' do
      before do
        allow(AppSettings.config.slack).to receive(:bot_token).and_return('xoxb-test')
        allow(AppSettings.config.slack).to receive(:channel_id).and_return('C123')
      end
      
      it 'creates a new visit' do
        expect {
          post visits_path, params: valid_params
        }.to change(Visit, :count).by(1)
      end
      
      it 'enqueues Slack notification job' do
        expect {
          post visits_path, params: valid_params
        }.to have_enqueued_job(SlackNotificationJob)
      end
      
      it 'redirects to complete page' do
        post visits_path, params: valid_params
        expect(response).to redirect_to(complete_path)
      end
      
      it 'stores visit ID in session' do
        post visits_path, params: valid_params
        expect(session[:last_visit_id]).to eq(Visit.last.id)
      end
    end
    
    context 'with invalid parameters' do
      let(:invalid_params) do
        {
          visit: {
            employee_id: nil,
            notes: 'Test'
          }
        }
      end
      
      it 'does not create a visit' do
        expect {
          post visits_path, params: invalid_params
        }.not_to change(Visit, :count)
      end
      
      it 'renders new template' do
        post visits_path, params: invalid_params
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end
  
  describe 'GET /visits/:id/status' do
    let(:visit) { create(:visit, employee: employee) }
    
    it 'returns visit status as JSON' do
      get status_visit_path(visit)
      
      expect(response).to have_http_status(:success)
      json = JSON.parse(response.body)
      expect(json['status']).to eq(visit.status)
      expect(json['responded']).to eq(visit.responded?)
    end
  end
end

# spec/requests/admin/employees_spec.rb
require 'rails_helper'

RSpec.describe 'Admin::Employees', type: :request do
  let(:admin) { create(:admin_user) }
  let(:department) { create(:department) }
  
  before do
    # ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³èªè¨¼ï¼‰
    post admin_login_path, params: {
      email: admin.email,
      password: 'password'
    }
  end
  
  describe 'GET /admin/employees' do
    it 'returns success' do
      get admin_employees_path
      expect(response).to have_http_status(:success)
    end
    
    it 'assigns @employees' do
      create_list(:employee, 3)
      get admin_employees_path
      expect(assigns(:employees).count).to eq(3)
    end
  end
  
  describe 'POST /admin/employees' do
    let(:valid_params) do
      {
        employee: {
          name: 'Test Employee',
          email: 'test@example.com',
          slack_user_id: 'U123456789',
          department_id: department.id
        }
      }
    end
    
    it 'creates a new employee' do
      expect {
        post admin_employees_path, params: valid_params
      }.to change(Employee, :count).by(1)
    end
    
    it 'redirects to index' do
      post admin_employees_path, params: valid_params
      expect(response).to redirect_to(admin_employees_path)
    end
  end
end
```

### 5. çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆï¼‰

```ruby
# spec/system/visitor_reception_spec.rb
require 'rails_helper'

RSpec.describe 'Visitor Reception', type: :system do
  include_context 'with slack mocked'
  
  let(:department) { create(:department, name: 'å–¶æ¥­éƒ¨') }
  let!(:employee) { create(:employee, name: 'å±±ç”°å¤ªéƒ', department: department) }
  
  before do
    driven_by(:rack_test)
    allow(AppSettings.config.slack).to receive(:bot_token).and_return('xoxb-test')
    allow(AppSettings.config.slack).to receive(:channel_id).and_return('C123')
  end
  
  scenario 'Visitor selects employee and submits visit' do
    # å¾“æ¥­å“¡ä¸€è¦§ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹
    visit root_path
    
    # å¾“æ¥­å“¡ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    expect(page).to have_content('å±±ç”°å¤ªéƒ')
    expect(page).to have_content('å–¶æ¥­éƒ¨')
    
    # å¾“æ¥­å“¡ã‚’é¸æŠ
    click_link 'å±±ç”°å¤ªéƒ'
    
    # è¨ªå•ç¢ºèªç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹
    expect(page).to have_content('è¨ªå•ç¢ºèª')
    expect(page).to have_content('å±±ç”°å¤ªéƒ')
    
    # ãƒ¡ãƒ¢ã‚’å…¥åŠ›
    fill_in 'ãƒ¡ãƒ¢', with: 'æ‰“ã¡åˆã‚ã›ã§æ¥ã¾ã—ãŸ'
    
    # å‘¼ã³å‡ºã™ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
    click_button 'å‘¼ã³å‡ºã™'
    
    # å®Œäº†ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹
    expect(page).to have_content('é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸ')
    expect(page).to have_content('å—ä»˜ãŒå®Œäº†ã—ã¾ã—ãŸ')
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹
    visit = Visit.last
    expect(visit.employee).to eq(employee)
    expect(visit.notes).to eq('æ‰“ã¡åˆã‚ã›ã§æ¥ã¾ã—ãŸ')
  end
  
  scenario 'Search employee by name' do
    create(:employee, name: 'ä½è—¤èŠ±å­', department: department)
    
    visit root_path
    
    # æ¤œç´¢ãƒ•ã‚©ãƒ¼ãƒ ã«å…¥åŠ›
    fill_in 'æ¤œç´¢', with: 'å±±ç”°'
    click_button 'æ¤œç´¢'
    
    # æ¤œç´¢çµæœãŒè¡¨ç¤ºã•ã‚Œã‚‹
    expect(page).to have_content('å±±ç”°å¤ªéƒ')
    expect(page).not_to have_content('ä½è—¤èŠ±å­')
  end
end

# spec/system/admin/employee_management_spec.rb
require 'rails_helper'

RSpec.describe 'Admin Employee Management', type: :system do
  let(:admin) { create(:admin_user) }
  let(:department) { create(:department) }
  
  before do
    driven_by(:rack_test)
    
    # ãƒ­ã‚°ã‚¤ãƒ³
    visit admin_login_path
    fill_in 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', with: admin.email
    fill_in 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰', with: 'password'
    click_button 'ãƒ­ã‚°ã‚¤ãƒ³'
  end
  
  scenario 'Admin creates new employee' do
    visit admin_employees_path
    
    click_link 'æ–°è¦ç™»éŒ²'
    
    fill_in 'åå‰', with: 'æ–°å…¥ç¤¾å“¡'
    fill_in 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', with: 'newbie@example.com'
    fill_in 'Slack User ID', with: 'U123456789'
    select department.name, from: 'éƒ¨ç½²'
    
    click_button 'ç™»éŒ²'
    
    expect(page).to have_content('å¾“æ¥­å“¡ã‚’ç™»éŒ²ã—ã¾ã—ãŸ')
    expect(page).to have_content('æ–°å…¥ç¤¾å“¡')
  end
  
  scenario 'Admin edits employee' do
    employee = create(:employee, department: department)
    
    visit admin_employees_path
    
    click_link 'ç·¨é›†', match: :first
    
    fill_in 'åå‰', with: 'æ›´æ–°ã•ã‚ŒãŸåå‰'
    click_button 'æ›´æ–°'
    
    expect(page).to have_content('å¾“æ¥­å“¡ã‚’æ›´æ–°ã—ã¾ã—ãŸ')
    expect(page).to have_content('æ›´æ–°ã•ã‚ŒãŸåå‰')
  end
end
```

---

## å®Ÿè£…å„ªå…ˆåº¦

### ğŸ”´ Phase 1: ç·Šæ€¥å¯¾å¿œï¼ˆ1é€±é–“ï¼‰

**å„ªå…ˆåº¦: CRITICAL**

1. âœ… **AppConfigå®Ÿè£…** (2æ™‚é–“)
   - `config/initializers/app_config.rb`ä½œæˆ
   - ç’°å¢ƒå¤‰æ•°ã®æ•´ç†
   - å‹•ä½œç¢ºèª

2. âœ… **åŸºæœ¬ãƒ†ã‚¹ãƒˆã®è¿½åŠ ** (3æ—¥)
   - ãƒ¢ãƒ‡ãƒ«ãƒ†ã‚¹ãƒˆï¼ˆEmployee, Visit, Departmentï¼‰
   - ã‚µãƒ¼ãƒ“ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆSlackNotifier, EmployeeSyncerï¼‰
   - æœ€ä½é™ã®ã‚«ãƒãƒ¬ãƒƒã‚¸ç¢ºä¿

3. âœ… **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿®æ­£** (1æ—¥)
   - Slackç½²åæ¤œè¨¼ã®å³æ ¼åŒ–
   - SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ã®è¦‹ç›´ã—
   - Rate Limitingè¿½åŠ 

### ğŸŸ¡ Phase 2: é‡è¦æ”¹å–„ï¼ˆ2é€±é–“ï¼‰

**å„ªå…ˆåº¦: HIGH**

4. âœ… **Visitãƒ¢ãƒ‡ãƒ«ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°** (åŠæ—¥)
   - é‡è¤‡ãƒ¡ã‚½ãƒƒãƒ‰ã®å‰Šé™¤
   - å®šæ•°åŒ–

5. âœ… **N+1ã‚¯ã‚¨ãƒªã®è§£æ¶ˆ** (1æ—¥)
   - includesè¿½åŠ 
   - ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥å°å…¥

6. âœ… **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®çµ±ä¸€** (2æ—¥)
   - Service Objectãƒ‘ã‚¿ãƒ¼ãƒ³ã®å°å…¥
   - Result Objectã®å®Ÿè£…

7. âœ… **è¨­å®šç®¡ç†ã®æ”¹å–„** (1æ—¥)
   - dry-configurableå°å…¥
   - ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã®æ’é™¤

### ğŸŸ¢ Phase 3: å“è³ªå‘ä¸Šï¼ˆ3é€±é–“ï¼‰

**å„ªå…ˆåº¦: MEDIUM**

8. â¬œ **ãƒ•ãƒ«ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ** (1é€±é–“)
   - çµ±åˆãƒ†ã‚¹ãƒˆ
   - ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
   - 80%ä»¥ä¸Šã®ã‚«ãƒãƒ¬ãƒƒã‚¸

9. â¬œ **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–** (1é€±é–“)
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
   - ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥
   - ã‚¸ãƒ§ãƒ–æœ€é©åŒ–

10. â¬œ **å›½éš›åŒ–å¯¾å¿œ** (3æ—¥)
    - I18nè¨­å®š
    - æ—¥æœ¬èª/è‹±èªå¯¾å¿œ

### âšª Phase 4: å°†æ¥å¯¾å¿œï¼ˆç¶™ç¶šçš„ï¼‰

**å„ªå…ˆåº¦: LOW**

11. â¬œ **API ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°** (1é€±é–“)
    - REST API v1å®Ÿè£…
    - èªè¨¼æ©Ÿæ§‹

12. â¬œ **ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ»ãƒ­ã‚®ãƒ³ã‚°** (1é€±é–“)
    - æ§‹é€ åŒ–ãƒ­ã‚°
    - APMå°å…¥
    - ã‚¨ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°

13. â¬œ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ** (3æ—¥)
    - Swagger/OpenAPI
    - APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

---

## ã¾ã¨ã‚

### ç¾çŠ¶ã®è©•ä¾¡

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯å…¨ä½“çš„ã«**è‰¯å¥½ãªè¨­è¨ˆ**ãŒãªã•ã‚Œã¦ã„ã¾ã™ãŒã€ä»¥ä¸‹ã®ç‚¹ã§æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚Šã¾ã™ï¼š

âœ… **è‰¯ã„ç‚¹**
- ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®é©åˆ‡ãªåˆ†é›¢
- ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ã®å®Ÿè£…
- éåŒæœŸã‚¸ãƒ§ãƒ–ã®æ´»ç”¨
- è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

âŒ **æ”¹å–„ãŒå¿…è¦ãªç‚¹**
- AppConfigæœªå®šç¾©ï¼ˆè‡´å‘½çš„ï¼‰
- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ä¸åœ¨
- ä¸€éƒ¨ã®é‡è¤‡ã‚³ãƒ¼ãƒ‰
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®ä½™åœ°

### æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

1. **ä»Šã™ã**: AppConfigã‚’å®Ÿè£…ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•å¯èƒ½ã«ã™ã‚‹
2. **1é€±é–“ä»¥å†…**: åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã—ã¦å“è³ªã‚’æ‹…ä¿
3. **1ãƒ¶æœˆä»¥å†…**: ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
4. **ç¶™ç¶šçš„**: ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®å‘ä¸Šã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°å¼·åŒ–

### æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

ã“ã‚Œã‚‰ã®æ”¹å–„ã«ã‚ˆã‚Šï¼š
- **ä¿¡é ¼æ€§**: ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚Šå“è³ªãŒä¿è¨¼ã•ã‚Œã‚‹
- **ä¿å®ˆæ€§**: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã«ã‚ˆã‚Šå¤‰æ›´ãŒå®¹æ˜“ã«ãªã‚‹
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: æœ€é©åŒ–ã«ã‚ˆã‚Šå¿œç­”é€Ÿåº¦ãŒå‘ä¸Šã™ã‚‹
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: å¯¾ç­–å¼·åŒ–ã«ã‚ˆã‚Šå®‰å…¨æ€§ãŒå‘ä¸Šã™ã‚‹

---

**ä½œæˆè€…**: Claude (Anthropic)  
**ä½œæˆæ—¥**: 2025å¹´11æœˆ10æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0
